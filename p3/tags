!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ARG	Makefile	/^ARG = -lglut -lGL -lm -g -Wall -std=c++11 -DDEBUG_PRINT $/;"	m
BRESENHAM	graph.h	39;"	d
C	Makefile	/^C = g++$/;"	m
COMMON_TYPE_H	common_type.h	2;"	d
ClipRegion	common_type.h	/^}ClipRegion;$/;"	t	typeref:struct:__anon7
Color	common_type.h	/^}Color;$/;"	t	typeref:struct:__anon1
DDA	graph.h	40;"	d
DEBUG_PRINT	common_type.h	7;"	d
DPRINT	common_type.h	10;"	d
DPRINT	common_type.h	12;"	d
Edge	common_type.h	/^} Edge;$/;"	t	typeref:struct:__anon5
GRAPH_H	graph.h	2;"	d
Graph	graph.cpp	/^Graph::Graph(int width, int height, float *PixelBufferPtr){$/;"	f	class:Graph
Graph	graph.h	/^class Graph {$/;"	c
Ia	common_type.h	/^  float Ia;$/;"	m	struct:__anon9
Il	common_type.h	/^  float Il; $/;"	m	struct:__anon9
MAX	common_type.h	16;"	d
MENU_CLIP_BRESENHAM	user_io.h	27;"	d
MENU_CLIP_DDA	user_io.h	26;"	d
MENU_DRAW_BRESENHAM	user_io.h	29;"	d
MENU_DRAW_DDA	user_io.h	28;"	d
MENU_GRAB_CLIP_REGION	user_io.h	34;"	d
MENU_GRAB_ROTATION_ANGLE	user_io.h	31;"	d
MENU_GRAB_SCALE_FACTORS	user_io.h	33;"	d
MENU_GRAB_TRANSLATION_FACTORS	user_io.h	32;"	d
MENU_STATUS	user_io.h	30;"	d
MIN	common_type.h	15;"	d
PI	common_type.h	18;"	d
POLYHEDRON_H	polyhedron.h	2;"	d
PixelBuffer	graph.h	/^    float *PixelBuffer;$/;"	m	class:Graph
PixelBuffer	main.cpp	/^float *PixelBuffer; \/\/ global pixel buffer$/;"	v
Point	common_type.h	/^} Point;$/;"	t	typeref:struct:__anon2
Point_3D	common_type.h	/^}Point_3D;$/;"	t	typeref:struct:__anon4
Polyhedron	polyhedron.cpp	/^Polyhedron::Polyhedron(Graph **_graphs, Point_3D *_listOfPoints, int _numberOfPoints, Edge *_listOfEdges, int _numberOfEdges, Surface *_listOfSurfaces, int _numberOfSurfaces){ $/;"	f	class:Polyhedron
Polyhedron	polyhedron.h	/^class Polyhedron {$/;"	c
STATE_GRAB_COMMANDS	user_io.h	17;"	d
STATE_GRAB_DATA_CLIP_REGION	user_io.h	21;"	d
STATE_GRAB_DATA_DRAW_BRESENHAM	user_io.h	23;"	d
STATE_GRAB_DATA_DRAW_DDA	user_io.h	22;"	d
STATE_GRAB_DATA_ROTATION_ANGLE	user_io.h	18;"	d
STATE_GRAB_DATA_SCALE_FACTORS	user_io.h	20;"	d
STATE_GRAB_DATA_TRANSLATION_FACTORS	user_io.h	19;"	d
Scene	common_type.h	/^} Scene;$/;"	t	typeref:struct:__anon9
SubWindowPixelBuffer1	main.cpp	/^float *SubWindowPixelBuffer1;$/;"	v
SubWindowPixelBuffer2	main.cpp	/^float *SubWindowPixelBuffer2;$/;"	v
SubWindowPixelBuffer3	main.cpp	/^float *SubWindowPixelBuffer3;$/;"	v
Surface	common_type.h	/^typedef TriSurface Surface;$/;"	t
Transformation	common_type.h	/^}Transformation;$/;"	t	typeref:struct:__anon8
TriSurface	common_type.h	/^} TriSurface;$/;"	t	typeref:struct:__anon6
USER_IO_H	user_io.h	2;"	d
VECTOR_H	vector.h	2;"	d
Vector	common_type.h	/^} Vector;$/;"	t	typeref:struct:__anon3
Window	common_type.h	/^} Window;$/;"	t	typeref:struct:__anon10
_bresenham	polyhedron.cpp	/^int Polyhedron::_bresenham(Point pt1, Point pt2, int planeIndex){ \/\/for storing points, not drawing pixel$/;"	f	class:Polyhedron
_storeContourPoint	polyhedron.cpp	/^void Polyhedron:: _storeContourPoint(Point p, int planeIndex){$/;"	f	class:Polyhedron
_storeLinePoints	polyhedron.cpp	/^int Polyhedron::_storeLinePoints(Point p1, Point p2, int planeIndex){$/;"	f	class:Polyhedron
add	vector.cpp	/^Vector add(Vector v1, Vector v2){$/;"	f
applyPhong	polyhedron.cpp	/^void Polyhedron::applyPhong(Polyhedron **polyhedra, int numberOfPolyhedra, float Ia, float Il, Point_3D ff, Point_3D xx, int n ){$/;"	f	class:Polyhedron
b	common_type.h	/^  float b;$/;"	m	struct:__anon1
background_color	graph.h	/^  public:Color background_color;$/;"	m	class:Graph
bresenham	graph.cpp	/^int Graph::bresenham(Point pt1, Point pt2 ){ \/\/overloaded bresenham, each points has its own color$/;"	f	class:Graph
bresenham	graph.cpp	/^int Graph::bresenham(Point pt1, Point pt2, float r, float g, float b ){$/;"	f	class:Graph
callback_display	main.cpp	/^void callback_display(){$/;"	f
callback_keyboard	main.cpp	/^void callback_keyboard(unsigned char key, int x, int y){$/;"	f
callback_menu	main.cpp	/^void callback_menu(int state){$/;"	f
callback_subdisplay1	main.cpp	/^void callback_subdisplay1(){$/;"	f
callback_subdisplay2	main.cpp	/^void callback_subdisplay2(){$/;"	f
callback_subdisplay3	main.cpp	/^void callback_subdisplay3(){$/;"	f
centroid	polyhedron.h	/^  Point_3D centroid;$/;"	m	class:Polyhedron
clearContourPoints	polyhedron.cpp	/^void Polyhedron::clearContourPoints(int planeIndex){$/;"	f	class:Polyhedron
clearContourPointsForEachPlane	polyhedron.cpp	/^void Polyhedron::clearContourPointsForEachPlane(int numberOfPlanes){$/;"	f	class:Polyhedron
compareXValue	polyhedron.cpp	/^bool compareXValue(Point p1, Point p2){$/;"	f
cr	common_type.h	/^  ClipRegion cr;$/;"	m	struct:__anon10
createMenu	main.cpp	/^void createMenu(void){     $/;"	f
ctov	vector.cpp	/^Vector ctov(Color c){$/;"	f
dda	graph.cpp	/^int Graph::dda( Point p1, Point p2,  float r, float g, float b){ $/;"	f	class:Graph
determineStartAndEndPoints	graph.cpp	/^void determineStartAndEndPoints(Point p1, Point p2, int*x, int*y, int *x_end, int*y_end){$/;"	f
dotProduct	vector.cpp	/^float dotProduct(Vector v1, Vector v2){$/;"	f
draw	polyhedron.cpp	/^void Polyhedron::draw(){$/;"	f	class:Polyhedron
draw	polyhedron.cpp	/^void Polyhedron::draw(Color c){$/;"	f	class:Polyhedron
draw	polyhedron.cpp	/^void Polyhedron::draw(float r, float g, float b){$/;"	f	class:Polyhedron
drawLine	graph.cpp	/^int Graph::drawLine( Point p1, Point p2){$/;"	f	class:Graph
drawLine	graph.cpp	/^int Graph::drawLine( Point p1, Point p2,  float r, float g, float b){$/;"	f	class:Graph
drawLine	graph.cpp	/^int Graph::drawLine( Point p1, Point p2,  float r, float g, float b, int method){ $/;"	f	class:Graph
drawPixel	graph.cpp	/^int Graph::drawPixel(Point p){$/;"	f	class:Graph
drawPixel	graph.cpp	/^int Graph::drawPixel(int x, int y, Color c){$/;"	f	class:Graph
drawPixel	graph.cpp	/^int Graph::drawPixel(int x, int y, float r, float g, float b){$/;"	f	class:Graph
drawPolygon	graph.cpp	/^int Graph::drawPolygon( Point *listOfPoints, int numberOfPoints, float r, float g, float b){$/;"	f	class:Graph
drawPolyhedra	main.cpp	/^void drawPolyhedra(Polyhedron **polyhedra){$/;"	f
erase	polyhedron.cpp	/^void Polyhedron::erase(){$/;"	f	class:Polyhedron
ff	common_type.h	/^  Point_3D ff[3]; \/\/coord of FROM POINTS, view from xy-plane, xz-plane, yz-plane$/;"	m	struct:__anon9
fillScreen	graph.cpp	/^int Graph::fillScreen(float r, float g, float b){$/;"	f	class:Graph
findMaxIntensity	polyhedron.cpp	/^float Polyhedron::findMaxIntensity(Polyhedron **polyhedra, int numberOfPolyhedra){$/;"	f	class:Polyhedron
findNDCParams	polyhedron.cpp	/^void Polyhedron::findNDCParams(Polyhedron **polyhedra, int numberOfPolyhedra, float *delta, float *_xMin, float *_yMin, float *_zMin){$/;"	f	class:Polyhedron
g	common_type.h	/^  float g;$/;"	m	struct:__anon1
globalGraphs	main.cpp	/^Graph *globalGraphs[4];$/;"	v
globalPolyhedra	main.cpp	/^Polyhedron **globalPolyhedra;$/;"	v
graphs	common_type.h	/^  void **graphs;$/;"	m	struct:__anon10
graphs	polyhedron.h	/^  Graph **graphs;$/;"	m	class:Polyhedron
height	common_type.h	/^  int height;$/;"	m	struct:__anon10
inputBuffer	common_type.h	/^  std::string *inputBuffer;$/;"	m	struct:__anon10
input_buffer	main.cpp	/^std::string input_buffer;$/;"	v
int8	common_type.h	/^typedef char          int8; $/;"	t
intensity	common_type.h	/^  Color intensity; \/\/ directly from phont model$/;"	m	struct:__anon4
isNDC	polyhedron.cpp	/^bool Polyhedron::isNDC(Point_3D p){$/;"	f	class:Polyhedron
ka	common_type.h	/^  Color ka; \/\/ambient light coeff$/;"	m	struct:__anon4
ka	common_type.h	/^  Color ka;$/;"	m	struct:__anon9
kd	common_type.h	/^  Color kd; \/\/diffusive  coefficient(the color of a point in the original object) ;$/;"	m	struct:__anon4
ks	common_type.h	/^  Color ks; \/\/ specular coefficient(the highlightness of the material)$/;"	m	struct:__anon4
linearInterpolation	vector.cpp	/^Color linearInterpolation(float mid, float begin, float end, Color Ibegin, Color Iend){$/;"	f
listOfContourPoints	polyhedron.h	/^  std::list<Point> *listOfContourPoints[3]; \/\/index 0 for xy, 1 for xz, 2 for yz$/;"	m	class:Polyhedron
listOfEdges	polyhedron.h	/^  Edge *listOfEdges; $/;"	m	class:Polyhedron
listOfPoints	polyhedron.h	/^  Point_3D* listOfPoints;$/;"	m	class:Polyhedron
listOfPointsNDC	polyhedron.h	/^  Point_3D* listOfPointsNDC;$/;"	m	class:Polyhedron
listOfSurfaces	polyhedron.h	/^  Surface *listOfSurfaces;$/;"	m	class:Polyhedron
magnitude	vector.cpp	/^float magnitude(Vector v){$/;"	f
main	main.cpp	/^int main(int argc, char *argv[]){$/;"	f
minus	vector.cpp	/^Vector minus(Point_3D p2, Point_3D p1){$/;"	f
minus	vector.cpp	/^Vector minus(Vector v1, Vector v2) {$/;"	f
multByScalar	vector.cpp	/^Color multByScalar(Color c, float scalar){$/;"	f
multByScalar	vector.cpp	/^Vector multByScalar(Vector v, float scalar){$/;"	f
n	common_type.h	/^  int n; \/\/ controls reflection intensity $/;"	m	struct:__anon9
nn	common_type.h	/^  Vector nn;\/\/normal vector;$/;"	m	struct:__anon4
normalVector	common_type.h	/^  Vector normalVector;$/;"	m	struct:__anon6
normalizeIntensities	polyhedron.cpp	/^void Polyhedron::normalizeIntensities(Polyhedron **polyhedra, int numberOfPolyhedra){$/;"	f	class:Polyhedron
normalizedIntensity	common_type.h	/^  Color normalizedIntensity; $/;"	m	struct:__anon2
normalizedIntensity	common_type.h	/^  Color normalizedIntensity; \/\/ relative to all points in the scene$/;"	m	struct:__anon4
numberOfEdges	polyhedron.h	/^  int numberOfEdges;$/;"	m	class:Polyhedron
numberOfPlanes	polyhedron.h	/^  int numberOfPlanes;$/;"	m	class:Polyhedron
numberOfPoints	polyhedron.h	/^  int numberOfPoints;$/;"	m	class:Polyhedron
numberOfPolygons	common_type.h	/^  int numberOfPolygons;$/;"	m	struct:__anon10
numberOfPolyhedra	common_type.h	/^  int numberOfPolyhedra; $/;"	m	struct:__anon10
numberOfSurfaces	polyhedron.h	/^  int numberOfSurfaces;$/;"	m	class:Polyhedron
obliqueProj	polyhedron.cpp	/^Point_3D Polyhedron::obliqueProj(Point_3D dirVector, Point_3D p){ \/\/oblique projection on  xy-plane$/;"	f	class:Polyhedron
outOfBound	graph.cpp	/^bool Graph::outOfBound(int x, int y){$/;"	f	class:Graph
p1Index	common_type.h	/^  int p1Index;  $/;"	m	struct:__anon5
p1Index	common_type.h	/^  int p1Index;$/;"	m	struct:__anon6
p2Index	common_type.h	/^  int p2Index;$/;"	m	struct:__anon5
p2Index	common_type.h	/^  int p2Index;$/;"	m	struct:__anon6
p3Index	common_type.h	/^  int p3Index;$/;"	m	struct:__anon6
pairOfPointsForRotAxis	common_type.h	/^  Point_3D pairOfPointsForRotAxis[2];$/;"	m	struct:__anon8
phong	polyhedron.cpp	/^Color Polyhedron::phong(Point_3D p,  float Ia, float Il, Point_3D ff, Point_3D xx, int n ){$/;"	f	class:Polyhedron
phong	polyhedron.cpp	/^Vector Polyhedron::phong(Point_3D p, Vector ka, Vector kd, Vector ks, Vector nn, float Ia, float Il, Point_3D ff, int n, double C, Vector ll, Vector rr, Vector vv){$/;"	f	class:Polyhedron
printAttributes	polyhedron.cpp	/^void Polyhedron::printAttributes(){$/;"	f	class:Polyhedron
printContourPoints	polyhedron.cpp	/^void Polyhedron::printContourPoints(){$/;"	f	class:Polyhedron
printVector	vector.cpp	/^void printVector(const char *tag, Vector v){$/;"	f
r	common_type.h	/^  float r;$/;"	m	struct:__anon1
rasterize	polyhedron.cpp	/^void Polyhedron::rasterize(float r, float g, float b){$/;"	f	class:Polyhedron
readFile	user_io.cpp	/^void readFile(std::ifstream &ifs){$/;"	f
readHeaders	user_io.cpp	/^void readHeaders(std::ifstream *ifs, int*numberOfObjects){$/;"	f
readPolyhedra	user_io.cpp	/^void readPolyhedra(std::ifstream *ifs, Graph **graphs, Polyhedron **polyhedra, int numberOfPolyhedra){ $/;"	f
rotate	polyhedron.cpp	/^void Polyhedron::rotate(Point_3D p1, Point_3D p2, float angle){$/;"	f	class:Polyhedron
rotation_angle	common_type.h	/^  float rotation_angle;$/;"	m	struct:__anon8
savePolyhedraToFile	polyhedron.cpp	/^void Polyhedron::savePolyhedraToFile(Polyhedron **polyhedra, Window *window, const char *filename){$/;"	f	class:Polyhedron
scale	polyhedron.cpp	/^void Polyhedron::scale(float alpha){$/;"	f	class:Polyhedron
scale	polyhedron.cpp	/^void Polyhedron::scale(float alpha, float beta, float gamma){$/;"	f	class:Polyhedron
scale_alpha	common_type.h	/^  float scale_alpha;$/;"	m	struct:__anon8
scene	common_type.h	/^  Scene scene;$/;"	m	struct:__anon10
selectedObject	common_type.h	/^  int selectedObject;$/;"	m	struct:__anon10
setCentroid	polyhedron.cpp	/^void Polyhedron::setCentroid(){$/;"	f	class:Polyhedron
setNDC	polyhedron.cpp	/^void Polyhedron::setNDC(float delta, float xMin, float yMin, float zMin){$/;"	f	class:Polyhedron
setNormalVector	polyhedron.cpp	/^void Polyhedron::setNormalVector(){ $/;"	f	class:Polyhedron
setNormalVectors	polyhedron.cpp	/^void Polyhedron::setNormalVectors(Polyhedron **polyhedra, int numberOfPolyhedra){$/;"	f	class:Polyhedron
setPhongKCoeff	polyhedron.cpp	/^void Polyhedron::setPhongKCoeff(Color ka, Color kd, Color ks){ $/;"	f	class:Polyhedron
setPhongKCoeffForEachPolyhedron	polyhedron.cpp	/^void Polyhedron::setPhongKCoeffForEachPolyhedron(Polyhedron **polyhedra, int numberOfPolyhedra, Color ka, Color kd, Color ks){$/;"	f	class:Polyhedron
setPhongParams	polyhedron.cpp	/^void Polyhedron::setPhongParams(Polyhedron**polyhedra, int numberOfPolyhedra, Color ka, Color kd, Color ks){$/;"	f	class:Polyhedron
setupContourPoints	polyhedron.cpp	/^void Polyhedron::setupContourPoints(){$/;"	f	class:Polyhedron
state	common_type.h	/^  int state;$/;"	m	struct:__anon10
storeOriginalPointsToContourPointsForEachPlane	polyhedron.cpp	/^void Polyhedron::storeOriginalPointsToContourPointsForEachPlane(){$/;"	f	class:Polyhedron
swapXY	graph.cpp	/^void swapXY(Point *p1){$/;"	f
tf	common_type.h	/^  Transformation tf;   $/;"	m	struct:__anon10
translate	polyhedron.cpp	/^void Polyhedron::translate(float x_offset, float y_offset, float z_offset){$/;"	f	class:Polyhedron
uint8	common_type.h	/^typedef unsigned char uint8;$/;"	t
unitVector	vector.cpp	/^Vector unitVector(Point_3D p){$/;"	f
unitVector	vector.cpp	/^Vector unitVector(Vector p){$/;"	f
updateRotationAxis	polyhedron.cpp	/^void Polyhedron::updateRotationAxis(Polyhedron **polyhedra, int numberOfPolyhedra, Point_3D *pairOfPoints){$/;"	f	class:Polyhedron
updateScreen	main.cpp	/^void updateScreen(Polyhedron **polyhedra){$/;"	f
vtoc	vector.cpp	/^Color vtoc(Vector v){$/;"	f
width	common_type.h	/^  int width;$/;"	m	struct:__anon10
window	main.cpp	/^Window window;$/;"	v
windowInit	main.cpp	/^void windowInit(Window *window){$/;"	f
window_height	graph.h	/^  int window_height;$/;"	m	class:Graph
window_width	graph.h	/^  int window_width;$/;"	m	class:Graph
x	common_type.h	/^  float x;$/;"	m	struct:__anon3
x	common_type.h	/^  float x;$/;"	m	struct:__anon4
x	common_type.h	/^  int x;$/;"	m	struct:__anon2
xMax	common_type.h	/^  int xMax;$/;"	m	struct:__anon7
xMin	common_type.h	/^  int xMin;$/;"	m	struct:__anon7
x_offset	common_type.h	/^  float x_offset;$/;"	m	struct:__anon8
xx	common_type.h	/^  Point_3D xx; \/\/ coord. of light src$/;"	m	struct:__anon9
y	common_type.h	/^  float y;$/;"	m	struct:__anon3
y	common_type.h	/^  float y;$/;"	m	struct:__anon4
y	common_type.h	/^  int y;$/;"	m	struct:__anon2
yMax	common_type.h	/^  int yMax;$/;"	m	struct:__anon7
yMin	common_type.h	/^  int yMin;$/;"	m	struct:__anon7
y_offset	common_type.h	/^  float y_offset;$/;"	m	struct:__anon8
z	common_type.h	/^  float z;$/;"	m	struct:__anon3
z	common_type.h	/^  float z;$/;"	m	struct:__anon4
z_offset	common_type.h	/^  float z_offset;$/;"	m	struct:__anon8
